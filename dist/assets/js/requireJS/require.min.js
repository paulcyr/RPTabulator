'use strict';var _typeof='function'==typeof Symbol&&'symbol'==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&'function'==typeof Symbol&&obj.constructor===Symbol?'symbol':typeof obj},requirejs,_require,define;/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.2.0 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/requirejs/LICENSE
 *///Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true *//*global window, navigator, document, importScripts, setTimeout, opera */(function(global){//Could match something like ')//comment', do not lose the prefix to comment.
function commentReplace(r,t,n,d){return d||''}function isFunction(r){return'[object Function]'===ostring.call(r)}function isArray(r){return'[object Array]'===ostring.call(r)}/**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */function each(r,t){if(r){var n;for(n=0;n<r.length&&!(r[n]&&t(r[n],n,r));n+=1);}}/**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */function eachReverse(r,t){if(r){var n;for(n=r.length-1;-1<n&&!(r[n]&&t(r[n],n,r));n-=1);}}function hasProp(r,t){return hasOwn.call(r,t)}function getOwn(r,t){return hasProp(r,t)&&r[t]}/**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */function eachProp(r,t){for(var n in r)if(hasProp(r,n)&&t(r[n],n))break}/**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */function mixin(r,t,n,d){return t&&eachProp(t,function(a,o){(n||!hasProp(r,o))&&(!d||'object'!=('undefined'==typeof a?'undefined':_typeof(a))||!a||isArray(a)||isFunction(a)||a instanceof RegExp?r[o]=a:(!r[o]&&(r[o]={}),mixin(r[o],a,n,d)))}),r}//Similar to Function.prototype.bind, but the 'this' object is specified
//first, since it is easier to read/figure out what 'this' will be.
function bind(r,t){return function(){return t.apply(r,arguments)}}function scripts(){return document.getElementsByTagName('script')}function defaultOnError(r){throw r}//Allow getting a global that is expressed in
//dot notation, like 'a.b.c'.
function getGlobal(r){if(!r)return r;var t=global;return each(r.split('.'),function(n){t=t[n]}),t}/**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */function makeError(r,t,n,d){var a=new Error(t+'\nhttp://requirejs.org/docs/errors.html#'+r);return a.requireType=r,a.requireModules=d,n&&(a.originalError=n),a}function getInteractiveScript(){return interactiveScript&&'interactive'===interactiveScript.readyState?interactiveScript:(eachReverse(scripts(),function(r){if('interactive'===r.readyState)return interactiveScript=r}),interactiveScript)}//Look for a data-main script attribute, which could also adjust the baseUrl.
var req,s,head,baseElement,dataMain,src,interactiveScript,currentlyAddingScript,mainScript,subPath,commentRegExp=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,cjsRequireRegExp=/[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,jsSuffixRegExp=/\.js$/,currDirRegExp=/^\.\//,op=Object.prototype,ostring=op.toString,hasOwn=op.hasOwnProperty,isBrowser=!!('undefined'!=typeof window&&'undefined'!=typeof navigator&&window.document),isWebWorker=!isBrowser&&'undefined'!=typeof importScripts,//PS3 indicates loaded and complete, but need to wait for complete
//specifically. Sequence is 'loading', 'loaded', execution,
// then 'complete'. The UA check is unfortunate, but not sure how
//to feature test w/o causing perf issues.
readyRegExp=isBrowser&&'PLAYSTATION 3'===navigator.platform?/^complete$/:/^(complete|loaded)$/,defContextName='_',//Oh the tragedy, detecting opera. See the usage of isOpera for reason.
isOpera='undefined'!=typeof opera&&'[object Opera]'===opera.toString(),contexts={},cfg={},globalDefQueue=[],useInteractive=!1;if('undefined'==typeof define){if('undefined'!=typeof requirejs){if(isFunction(requirejs))//Do not overwrite an existing requirejs instance.
return;cfg=requirejs,requirejs=void 0}//Allow for a require config object
'undefined'==typeof _require||isFunction(_require)||(cfg=_require,_require=void 0),req=requirejs=function requirejs(r,t,n,d){//Find the right context, use default
var a,o,p=defContextName;// Determine if have config object in the call.
return isArray(r)||'string'==typeof r||(o=r,isArray(t)?(r=t,t=n,n=d):r=[]),o&&o.context&&(p=o.context),a=getOwn(contexts,p),a||(a=contexts[p]=req.s.newContext(p)),o&&a.configure(o),a.require(r,t,n)},req.config=function(r){return req(r)},req.nextTick='undefined'==typeof setTimeout?function(r){r()}:function(r){setTimeout(r,4)},_require||(_require=req),req.version='2.2.0',req.jsExtRegExp=/^\/|:|\?|\.js$/,req.isBrowser=isBrowser,s=req.s={contexts:contexts,newContext:function newContext(t){/**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */function n(I){var _,F;for(_=0;_<I.length;_++)if(F=I[_],'.'===F)I.splice(_,1),_-=1;else if('..'===F)// If at the start, or previous value is still ..,
// keep them so that when converted to a path it may
// still work when converted to a path, even though
// as an ID it is less than ideal. In larger point
// releases, may be better to just kick out an error.
if(0===_||1===_&&'..'===I[2]||'..'===I[_-1])continue;else 0<_&&(I.splice(_-1,2),_-=2)}/**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */function d(I,_,F){var P,J,Y,K,H,W,X,G,Z,$,V,ee,re=_&&_.split('/'),te=A.map,ie=te&&te['*'];//Adjust any relative paths.
//Apply map config if available.
if(I&&(I=I.split('/'),X=I.length-1,A.nodeIdCompat&&jsSuffixRegExp.test(I[X])&&(I[X]=I[X].replace(jsSuffixRegExp,'')),'.'===I[0].charAt(0)&&re&&(ee=re.slice(0,re.length-1),I=ee.concat(I)),n(I),I=I.join('/')),F&&te&&(re||ie)){Y=I.split('/');outerLoop:for(K=Y.length;0<K;K-=1){if(W=Y.slice(0,K).join('/'),re)//Find the longest baseName segment match in the config.
//So, do joins on the biggest to smallest lengths of baseParts.
for(H=re.length;0<H;H-=1)//baseName segment has config, find if it has one for
//this name.
if(J=getOwn(te,re.slice(0,H).join('/')),J&&(J=getOwn(J,W),J)){G=J,Z=K;break outerLoop}//Check for a star map match, but just hold on to it,
//if there is a shorter segment match later in a matching
//config, then favor over this star map.
!$&&ie&&getOwn(ie,W)&&($=getOwn(ie,W),V=K)}!G&&$&&(G=$,Z=V),G&&(Y.splice(0,Z,G),I=Y.join('/'))}// If the name points to a package's name, use
// the package main instead.
return P=getOwn(A.pkgs,I),P?P:I}function a(I){isBrowser&&each(scripts(),function(_){if(_.getAttribute('data-requiremodule')===I&&_.getAttribute('data-requirecontext')===S.contextName)return _.parentNode.removeChild(_),!0})}function o(I){var _=getOwn(A.paths,I);if(_&&isArray(_)&&1<_.length)return _.shift(),S.require.undef(I),S.makeRequire(null,{skipMap:!0})([I]),!0}//Turns a plugin!resource to [plugin, resource]
//with the plugin being undefined if the name
//did not have a plugin prefix.
function p(I){var _,F=I?I.indexOf('!'):-1;return-1<F&&(_=I.substring(0,F),I=I.substring(F+1,I.length)),[_,I]}/**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */function u(I,_,F,P){var J,Y,K,H,W=null,X=_?_.name:null,G=I,Z=!0,$='';//If no name, then it means it is a require call, generate an
//internal name.
return I||(Z=!1,I='_@r'+(B+=1)),H=p(I),W=H[0],I=H[1],W&&(W=d(W,X,P),Y=getOwn(R,W)),I&&(W?Y&&Y.normalize?$=Y.normalize(I,function(V){return d(V,X,P)}):$=-1===I.indexOf('!')?d(I,X,P):I:($=d(I,X,P),H=p($),W=H[0],$=H[1],F=!0,J=S.nameToUrl($))),K=!W||Y||F?'':'_unnormalized'+(Q+=1),{prefix:W,name:$,parentMap:_,unnormalized:!!K,url:J,originalName:G,isDefine:Z,id:(W?W+'!'+$:$)+K}}function l(I){var _=I.id,F=getOwn(U,_);return F||(F=U[_]=new S.Module(I)),F}function m(I,_,F){var P=I.id,J=getOwn(U,P);hasProp(R,P)&&(!J||J.defineEmitComplete)?'defined'===_&&F(R[P]):(J=l(I),J.error&&'error'===_?F(J.error):J.on(_,F))}function c(I,_){var F=I.requireModules,P=!1;_?_(I):(each(F,function(J){var Y=getOwn(U,J);Y&&(Y.error=I,Y.events.error&&(P=!0,Y.emit('error',I)))}),!P&&req.onError(I))}/**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */function f(){globalDefQueue.length&&(each(globalDefQueue,function(I){var _=I[0];'string'==typeof _&&(S.defQueueMap[_]=!0),w.push(I)}),globalDefQueue=[])}function h(I){delete U[I],delete D[I]}function x(I,_,F){var P=I.map.id;I.error?I.emit('error',I.error):(_[P]=!0,each(I.depMaps,function(J,Y){var K=J.id,H=getOwn(U,K);//Only force things that have not completed
//being defined, so still in the registry,
//and only if it has not been matched up
//in the module already.
!H||I.depMatched[Y]||F[K]||(getOwn(_,K)?(I.defineDep(Y,R[K]),I.check()):x(H,_,F))}),F[P]=!0)}function b(){var I,_,F=1000*A.waitSeconds,//It is possible to disable the wait interval by using waitSeconds of 0.
P=F&&S.startTime+F<new Date().getTime(),J=[],Y=[],K=!1,H=!0;//Do not bother if this call was a result of a cycle break.
//Not expired, check for a cycle.
if(!y)return y=!0,eachProp(D,function(W){var X=W.map,G=X.id;//Skip things that are not enabled or in error state.
if(W.enabled&&(X.isDefine||Y.push(W),!W.error))//If the module should be executed, and it has not
//been inited and time is up, remember it.
if(!W.inited&&P)o(G)?(_=!0,K=!0):(J.push(G),a(G));else if(!W.inited&&W.fetched&&X.isDefine&&(K=!0,!X.prefix))//No reason to keep looking for unfinished
//loading. If the only stillLoading is a
//plugin resource though, keep going,
//because it may be that a plugin resource
//is waiting on a non-plugin cycle.
return H=!1}),P&&J.length?(I=makeError('timeout','Load timeout for modules: '+J,null,J),I.contextName=S.contextName,c(I)):void(H&&each(Y,function(W){x(W,{},{})}),(!P||_)&&K&&(isBrowser||isWebWorker)&&!C&&(C=setTimeout(function(){C=0,b()},50)),y=!1)}function M(I){hasProp(R,I[0])||l(u(I[0],null,!0)).init(I[1],I[2])}function E(I,_,F,P){I.detachEvent&&!isOpera?P&&I.detachEvent(P,_):I.removeEventListener(F,_,!1)}/**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */function k(I){//Using currentTarget instead of target for Firefox 2.0's sake. Not
//all old browsers will be supported, but this one was easy enough
//to support and still makes sense.
var _=I.currentTarget||I.srcElement;//Remove the listeners once here.
return E(_,S.onScriptLoad,'load','onreadystatechange'),E(_,S.onScriptError,'error'),{node:_,id:_&&_.getAttribute('data-requiremodule')}}function q(){var I;//Any defined modules in the global queue, intake them now.
//Make sure any remaining defQueue items get properly processed.
for(f();w.length;){if(I=w.shift(),null===I[0])return c(makeError('mismatch','Mismatched anonymous define() module: '+I[I.length-1]));M(I)}S.defQueueMap={}}var y,T,S,N,C,A={//Defaults. Do not set a default for map
//config to speed up normalize(), which
//will run faster if there is no default.
waitSeconds:7,baseUrl:'./',paths:{},bundles:{},pkgs:{},shim:{},config:{}},U={},//registry of just enabled modules, to speed
//cycle breaking code when lots of modules
//are registered, but not activated.
D={},L={},w=[],R={},O={},z={},B=1,Q=1;return N={require:function require(I){return I.require?I.require:I.require=S.makeRequire(I.map)},exports:function exports(I){if(I.usingExports=!0,I.map.isDefine)return I.exports?R[I.map.id]=I.exports:I.exports=R[I.map.id]={}},module:function module(I){return I.module?I.module:I.module={id:I.map.id,uri:I.map.url,config:function config(){return getOwn(A.config,I.map.id)||{}},exports:I.exports||(I.exports={})}}},T=function T(I){this.events=getOwn(L,I.id)||{},this.map=I,this.shim=getOwn(A.shim,I.id),this.depExports=[],this.depMaps=[],this.depMatched=[],this.pluginMaps={},this.depCount=0},T.prototype={init:function init(I,_,F,P){P=P||{},this.inited||(this.factory=_,F?this.on('error',F):this.events.error&&(F=bind(this,function(J){this.emit('error',J)})),this.depMaps=I&&I.slice(0),this.errback=F,this.inited=!0,this.ignore=P.ignore,P.enabled||this.enabled?this.enable():this.check())},defineDep:function defineDep(I,_){this.depMatched[I]||(this.depMatched[I]=!0,this.depCount-=1,this.depExports[I]=_)},fetch:function fetch(){if(!this.fetched){this.fetched=!0,S.startTime=new Date().getTime();var I=this.map;//If the manager is for a plugin managed resource,
//ask the plugin to load it now.
return this.shim?void S.makeRequire(this.map,{enableBuildCallback:!0})(this.shim.deps||[],bind(this,function(){return I.prefix?this.callPlugin():this.load()})):I.prefix?this.callPlugin():this.load()}},load:function load(){var I=this.map.url;//Regular dependency.
O[I]||(O[I]=!0,S.load(this.map.id,I))},/**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */check:function check(){if(this.enabled&&!this.enabling){var I,_,F=this.map.id,P=this.depExports,J=this.exports,Y=this.factory;if(!this.inited)hasProp(S.defQueueMap,F)||this.fetch();else if(this.error)this.emit('error',this.error);else if(!this.defining){if(this.defining=!0,1>this.depCount&&!this.defined){if(isFunction(Y)){//If there is an error listener, favor passing
//to that instead of throwing an error. However,
//only do it for define()'d  modules. require
//errbacks should not be called for failures in
//their callbacks (#699). However if a global
//onError is set, use that.
if(this.events.error&&this.map.isDefine||req.onError!==defaultOnError)try{J=S.execCb(F,Y,P,J)}catch(H){I=H}else J=S.execCb(F,Y,P,J);// Favor return value over exports. If node/cjs in play,
// then will not have a return value anyway. Favor
// module.exports assignment over exports object.
if(this.map.isDefine&&void 0===J&&(_=this.module,_?J=_.exports:this.usingExports&&(J=this.exports)),I)return I.requireMap=this.map,I.requireModules=this.map.isDefine?[this.map.id]:null,I.requireType=this.map.isDefine?'define':'require',c(this.error=I)}else J=Y;if(this.exports=J,this.map.isDefine&&!this.ignore&&(R[F]=J,req.onResourceLoad)){var K=[];each(this.depMaps,function(H){K.push(H.normalizedMap||H)}),req.onResourceLoad(S,this.map,K)}//Clean up
h(F),this.defined=!0}//Finished the define stage. Allow calling check again
//to allow define notifications below in the case of a
//cycle.
this.defining=!1,this.defined&&!this.defineEmitted&&(this.defineEmitted=!0,this.emit('defined',this.exports),this.defineEmitComplete=!0)}}},callPlugin:function callPlugin(){var I=this.map,_=I.id,//Map already normalized the prefix.
F=u(I.prefix);//Mark this as a dependency for this plugin, so it
//can be traced for cycles.
this.depMaps.push(F),m(F,'defined',bind(this,function(P){var J,Y,K,H=getOwn(z,this.map.id),W=this.map.name,X=this.map.parentMap?this.map.parentMap.name:null,G=S.makeRequire(I.parentMap,{enableBuildCallback:!0});//If current map is not normalized, wait for that
//normalized name to load instead of continuing.
return this.map.unnormalized?(P.normalize&&(W=P.normalize(W,function(Z){return d(Z,X,!0)})||''),Y=u(I.prefix+'!'+W,this.map.parentMap),m(Y,'defined',bind(this,function(Z){this.map.normalizedMap=Y,this.init([],function(){return Z},null,{enabled:!0,ignore:!0})})),K=getOwn(U,Y.id),void(K&&(this.depMaps.push(Y),this.events.error&&K.on('error',bind(this,function(Z){this.emit('error',Z)})),K.enable()))):H?(this.map.url=S.nameToUrl(H),void this.load()):void(J=bind(this,function(Z){this.init([],function(){return Z},null,{enabled:!0})}),J.error=bind(this,function(Z){this.inited=!0,this.error=Z,Z.requireModules=[_],eachProp(U,function($){0===$.map.id.indexOf(_+'_unnormalized')&&h($.map.id)}),c(Z)}),J.fromText=bind(this,function(Z,$){/*jslint evil: true */var V=I.name,ee=u(V),re=useInteractive;//As of 2.1.0, support just passing the text, to reinforce
//fromText only being called once per resource. Still
//support old style of passing moduleName but discard
//that moduleName in favor of the internal ref.
$&&(Z=$),re&&(useInteractive=!1),l(ee),hasProp(A.config,_)&&(A.config[V]=A.config[_]);try{req.exec(Z)}catch(te){return c(makeError('fromtexteval','fromText eval for '+_+' failed: '+te,te,[_]))}re&&(useInteractive=!0),this.depMaps.push(ee),S.completeLoad(V),G([V],J)}),P.load(I.name,G,J,A));//If a paths config, then just load that file instead to
//resolve the plugin, as it is built into that paths layer.
})),S.enable(F,this),this.pluginMaps[F.id]=F},enable:function enable(){D[this.map.id]=this,this.enabled=!0,this.enabling=!0,each(this.depMaps,bind(this,function(I,_){var F,P,J;if('string'==typeof I){if(I=u(I,this.map.isDefine?this.map:this.map.parentMap,!1,!this.skipMap),this.depMaps[_]=I,J=getOwn(N,I.id),J)return void(this.depExports[_]=J(this));this.depCount+=1,m(I,'defined',bind(this,function(Y){this.undefed||(this.defineDep(_,Y),this.check())})),this.errback?m(I,'error',bind(this,this.errback)):this.events.error&&m(I,'error',bind(this,function(Y){this.emit('error',Y)}))}F=I.id,P=U[F],hasProp(N,F)||!P||P.enabled||S.enable(I,this)})),eachProp(this.pluginMaps,bind(this,function(I){var _=getOwn(U,I.id);_&&!_.enabled&&S.enable(I,this)})),this.enabling=!1,this.check()},on:function on(I,_){var F=this.events[I];F||(F=this.events[I]=[]),F.push(_)},emit:function emit(I,_){each(this.events[I],function(F){F(_)}),'error'===I&&delete this.events[I]}},S={config:A,contextName:t,registry:U,defined:R,urlFetched:O,defQueue:w,defQueueMap:{},Module:T,makeModuleMap:u,nextTick:req.nextTick,onError:c,/**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */configure:function configure(I){// Convert old style urlArgs string to a function.
if(I.baseUrl&&'/'!==I.baseUrl.charAt(I.baseUrl.length-1)&&(I.baseUrl+='/'),'string'==typeof I.urlArgs){var _=I.urlArgs;I.urlArgs=function(J,Y){return(-1===Y.indexOf('?')?'?':'&')+_}}//Save off the paths since they require special processing,
//they are additive.
var F=A.shim,P={paths:!0,bundles:!0,config:!0,map:!0};eachProp(I,function(J,Y){P[Y]?(!A[Y]&&(A[Y]={}),mixin(A[Y],J,!0,!0)):A[Y]=J}),I.bundles&&eachProp(I.bundles,function(J,Y){each(J,function(K){K!==Y&&(z[K]=Y)})}),I.shim&&(eachProp(I.shim,function(J,Y){isArray(J)&&(J={deps:J}),(J.exports||J.init)&&!J.exportsFn&&(J.exportsFn=S.makeShimExports(J)),F[Y]=J}),A.shim=F),I.packages&&each(I.packages,function(J){var Y,K;J='string'==typeof J?{name:J}:J,K=J.name,Y=J.location,Y&&(A.paths[K]=J.location),A.pkgs[K]=J.name+'/'+(J.main||'main').replace(currDirRegExp,'').replace(jsSuffixRegExp,'')}),eachProp(U,function(J,Y){J.inited||J.map.unnormalized||(J.map=u(Y,null,!0))}),(I.deps||I.callback)&&S.require(I.deps||[],I.callback)},makeShimExports:function makeShimExports(I){return function(){var F;return I.init&&(F=I.init.apply(global,arguments)),F||I.exports&&getGlobal(I.exports)}},makeRequire:function makeRequire(I,_){function F(P,J,Y){var K,H,W;return(_.enableBuildCallback&&J&&isFunction(J)&&(J.__requireJsBuild=!0),'string'==typeof P)?isFunction(J)?c(makeError('requireargs','Invalid require call'),Y):I&&hasProp(N,P)?N[P](U[I.id]):req.get?req.get(S,P,I,F):(H=u(P,I,!1,!0),K=H.id,hasProp(R,K)?R[K]:c(makeError('notloaded','Module name "'+K+'" has not been loaded yet for context: '+t+(I?'':'. Use require([])')))):(q(),S.nextTick(function(){q(),W=l(u(null,I)),W.skipMap=_.skipMap,W.init(P,J,Y,{enabled:!0}),b()}),F);//Grab defines waiting in the global queue.
}return _=_||{},mixin(F,{isBrowser:isBrowser,/**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */toUrl:function toUrl(P){var J,Y=P.lastIndexOf('.'),K=P.split('/')[0];//Have a file extension alias, and it is not the
//dots from a relative path.
return-1!==Y&&('.'!==K&&'..'!==K||1<Y)&&(J=P.substring(Y,P.length),P=P.substring(0,Y)),S.nameToUrl(d(P,I&&I.id,!0),J,!0)},defined:function defined(P){return hasProp(R,u(P,I,!1,!0).id)},specified:function specified(P){return P=u(P,I,!1,!0).id,hasProp(R,P)||hasProp(U,P)}}),I||(F.undef=function(P){f();var J=u(P,I,!0),Y=getOwn(U,P);Y.undefed=!0,a(P),delete R[P],delete O[J.url],delete L[P],eachReverse(w,function(K,H){K[0]===P&&w.splice(H,1)}),delete S.defQueueMap[P],Y&&(Y.events.defined&&(L[P]=Y.events),h(P))}),F},/**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */enable:function enable(I){var _=getOwn(U,I.id);_&&l(I).enable()},/**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */completeLoad:function completeLoad(I){var _,F,P,J=getOwn(A.shim,I)||{},Y=J.exports;for(f();w.length;){if(F=w.shift(),null===F[0]){//If already found an anonymous module and bound it
//to this name, then this is some other anon module
//waiting for its completeLoad to fire.
if(F[0]=I,_)break;_=!0}else F[0]===I&&(_=!0);M(F)}if(S.defQueueMap={},P=getOwn(U,I),!_&&!hasProp(R,I)&&P&&!P.inited){if(A.enforceDefine&&(!Y||!getGlobal(Y)))return o(I)?void 0:c(makeError('nodefine','No define call for '+I,null,[I]));M([I,J.deps||[],J.exportsFn])}b()},/**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */nameToUrl:function nameToUrl(I,_,F){var P,J,Y,K,H,W,X,G=getOwn(A.pkgs,I);if(G&&(I=G),X=getOwn(z,I),X)return S.nameToUrl(X,_,F);//If a colon is in the URL, it indicates a protocol is used and it is just
//an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
//or ends with .js, then assume the user meant to use an url and not a module id.
//The slash is important for protocol-less URLs as well as full paths.
if(req.jsExtRegExp.test(I))H=I+(_||'');else{//For each module name segment, see if there is a path
//registered for it. Start with most specific name
//and work up from it.
for(P=A.paths,J=I.split('/'),Y=J.length;0<Y;Y-=1)if(K=J.slice(0,Y).join('/'),W=getOwn(P,K),W){isArray(W)&&(W=W[0]),J.splice(0,Y,W);break}//Join the path parts together, then figure out if baseUrl is needed.
H=J.join('/');var Z=A.useMinified?'.min.js':'.js';// custom modification to support inified files
H+=_||(/^data\:|^blob\:|\?/.test(H)||F?'':Z),H=('/'===H.charAt(0)||H.match(/^[\w\+\.\-]+:/)?'':A.baseUrl)+H}return A.urlArgs&&!/^blob\:/.test(H)?H+A.urlArgs(I,H):H},//Delegates to req.load. Broken out as a separate function to
//allow overriding in the optimizer.
load:function load(I,_){req.load(S,I,_)},/**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */execCb:function execCb(I,_,F,P){return _.apply(P,F)},/**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */onScriptLoad:function onScriptLoad(I){//Using currentTarget instead of target for Firefox 2.0's sake. Not
//all old browsers will be supported, but this one was easy enough
//to support and still makes sense.
if('load'===I.type||readyRegExp.test((I.currentTarget||I.srcElement).readyState)){interactiveScript=null;//Pull out the name of the module and the context.
var _=k(I);S.completeLoad(_.id)}},/**
             * Callback for script errors.
             */onScriptError:function onScriptError(I){var _=k(I);if(!o(_.id)){var F=[];return eachProp(U,function(P,J){0!==J.indexOf('_@r')&&each(P.depMaps,function(Y){if(Y.id===_.id)return F.push(J),!0})}),c(makeError('scripterror','Script error for "'+_.id+(F.length?'", needed by: '+F.join(', '):'"'),I,[_.id]))}}},S.require=S.makeRequire(),S}/**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */},req({}),each(['toUrl','undef','defined','specified'],function(r){req[r]=function(){var t=contexts[defContextName];return t.require[r].apply(t,arguments)}}),isBrowser&&(head=s.head=document.getElementsByTagName('head')[0],baseElement=document.getElementsByTagName('base')[0],baseElement&&(head=s.head=baseElement.parentNode)),req.onError=defaultOnError,req.createNode=function(r,t,n){var d=r.xhtml?document.createElementNS('http://www.w3.org/1999/xhtml','html:script'):document.createElement('script');return d.type=r.scriptType||'text/javascript',d.charset='utf-8',d.async=!0,d},req.load=function(r,t,n){var a,d=r&&r.config||{};if(isBrowser)return a=req.createNode(d,t,n),a.setAttribute('data-requirecontext',r.contextName),a.setAttribute('data-requiremodule',t),!a.attachEvent||a.attachEvent.toString&&0>a.attachEvent.toString().indexOf('[native code')||isOpera?(a.addEventListener('load',r.onScriptLoad,!1),a.addEventListener('error',r.onScriptError,!1)):(useInteractive=!0,a.attachEvent('onreadystatechange',r.onScriptLoad)),a.src=n,d.onNodeCreated&&d.onNodeCreated(a,d,t,n),currentlyAddingScript=a,baseElement?head.insertBefore(a,baseElement):head.appendChild(a),currentlyAddingScript=null,a;if(isWebWorker)try{setTimeout(function(){},0),importScripts(n),r.completeLoad(t)}catch(o){r.onError(makeError('importscripts','importScripts failed for '+t+' at '+n,o,[t]))}},isBrowser&&!cfg.skipDataMain&&eachReverse(scripts(),function(r){if(head||(head=r.parentNode),dataMain=r.getAttribute('data-main'),dataMain)return mainScript=dataMain,cfg.baseUrl||-1!==mainScript.indexOf('!')||(src=mainScript.split('/'),mainScript=src.pop(),subPath=src.length?src.join('/')+'/':'./',cfg.baseUrl=subPath),mainScript=mainScript.replace(jsSuffixRegExp,''),req.jsExtRegExp.test(mainScript)&&(mainScript=dataMain),cfg.deps=cfg.deps?cfg.deps.concat(mainScript):[mainScript],!0}),define=function define(r,t,n){var d,a;//Allow for anonymous modules
'string'!=typeof r&&(n=t,t=r,r=null),isArray(t)||(n=t,t=null),!t&&isFunction(n)&&(t=[],n.length&&(n.toString().replace(commentRegExp,commentReplace).replace(cjsRequireRegExp,function(o,p){t.push(p)}),t=(1===n.length?['require']:['require','exports','module']).concat(t))),useInteractive&&(d=currentlyAddingScript||getInteractiveScript(),d&&(!r&&(r=d.getAttribute('data-requiremodule')),a=contexts[d.getAttribute('data-requirecontext')])),a?(a.defQueue.push([r,t,n]),a.defQueueMap[r]=!0):globalDefQueue.push([r,t,n])},define.amd={jQuery:!0},req.exec=function(text){/*jslint evil: true */return eval(text)},req(cfg)}})(void 0);